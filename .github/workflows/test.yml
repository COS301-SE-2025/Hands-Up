name: End To End Tests

on:
  pull_request:
    branches: [main, dev]
  push:
    branches: [main, dev, tests/summary]


permissions:
  contents: read

jobs:
  run-cypress-tests:
    name: Cypress End to End Tests
    runs-on: ubuntu-latest

    env:
      DB_USER: ${{ secrets.DB_USER }}
      DB_PASS: ${{ secrets.DB_PASS }}
      DB_NAME: ${{ secrets.DB_NAME }}
      DB_HOST: localhost # This is for the API and frontend to connect to the host machine's exposed port 
      DB_PORT: 5432
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      API_PORT: 2000
      REACT_APP_API_URL: http://localhost:2000
      REACT_APP_TESTING_ENVIRONMENT: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install docker-compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      - name: Create .env file (for local testing/debugging, though direct env injection is better for CI)
        run: |
          echo "DB_USER=${{ secrets.DB_USER }}" > .env
          echo "DB_PASS=${{ secrets.DB_PASS }}" >> .env
          echo "DB_NAME=${{ secrets.DB_NAME }}" >> .env
          echo "DB_HOST=localhost" >> .env
          echo "DB_PORT=5432" >> .env
        working-directory: backend/database # Create .env in the correct directory for docker-compose to pick up

      # Start database services in detached mode
      - name: Start database services
        run: |
          cd backend/database
          docker-compose up -d --build

      # Enhanced database health check using pg_isready
      - name: Wait for PostgreSQL database to be ready
        run: |
          cd backend/database
          echo "Checking PostgreSQL database health..."
          # This loop attempts to connect to the database inside the container
          # using pg_isready for up to 60 seconds (30 * 2 seconds sleep).
          # It uses the service name 'postgres' for connection within the Docker network.
          for i in {1..30}; do
            if docker-compose exec -T postgres pg_isready -h localhost -p 5432 -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}"; then
              echo "✅ PostgreSQL database is ready!"
              break
            fi
            echo "Waiting for PostgreSQL database... (attempt $i/30)"
            sleep 2
          done
          # Fail the step if the database is still not ready after all attempts
          if ! docker-compose exec -T postgres pg_isready -h localhost -p 5432 -U "${{ secrets.DB_USER }}" -d "${{ secrets.DB_NAME }}"; then
            echo "❌ PostgreSQL database did not become ready in time."
            exit 1
          fi

      # Run migrations with explicit error handling for skipping
      - name: Run database migrations (and skip on failure)
        run: |
          cd backend/database
          echo "Attempting to run migrations..."
          set +e  # Temporarily disable exit on error for this block
          
          # Pass environment variables directly to the `docker-compose run` command
          # This ensures Flyway has the correct credentials.
          # Use `postgres` as the host for Flyway, as it's connecting to the service name
          # within the Docker Compose network.
          docker-compose run --rm \
            -e FLYWAY_URL="jdbc:postgresql://postgres:5432/${{ secrets.DB_NAME }}" \
            -e FLYWAY_USER="${{ secrets.DB_USER }}" \
            -e FLYWAY_PASSWORD="${{ secrets.DB_PASS }}" \
            flyway migrate
          
          MIGRATION_EXIT_CODE=$?
          
          if [ $MIGRATION_EXIT_CODE -eq 0 ]; then
            echo "✅ Migrations completed successfully"
          else
            echo "⚠️ Migrations failed (exit code $MIGRATION_EXIT_CODE), but continuing with tests."
            echo "This might be expected if the database is already up to date or for specific testing scenarios."
          fi
          
          set -e  # Re-enable exit on error for subsequent commands in this step

      # Install dependencies
      - name: Install root dependencies
        run: npm ci

      - name: Install backend API dependencies
        run: |
          cd backend/api
          npm ci

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci

      # Start services in the background and use `wait-on`
      - name: Start services (backend API and frontend)
        run: |
          # Debug: List files in backend/api
          echo "Files in backend/api directory:"
          ls -la backend/api/
          
          # Start backend API
          cd backend/api
          echo "Starting backend API..."
          if [ -f "handsUp.js" ]; then
            node handsUp.js > ../../backend.log 2>&1 & disown
            echo "Backend API started with handsUp.js"
          elif [ -f "handsUp.js" ]; then
            node handsUp.js > ../../backend.log 2>&1 & disown
            echo "Backend API started with handsUp.js"
          elif [ -f "index.js" ]; then
            node index.js > ../../backend.log 2>&1 & disown
            echo "Backend API started with index.js"
          else
            echo "Error: Could not find main backend file"
            echo "Available files:"
            ls -la
            exit 1
          fi

          # Start frontend application
          cd ../../frontend
          echo "Starting frontend..."
          npm start > ../frontend.log 2>&1 & disown
          echo "Frontend started in background."
        env:
          # Ensure these are correctly set for your application processes
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASS: ${{ secrets.DB_PASS }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_HOST: localhost # Your Node.js API connects to the host's exposed port 5432
          DB_PORT: 5432
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          REACT_APP_API_URL: http://localhost:2000
          REACT_APP_TESTING_ENVIRONMENT: true

      - name: Wait for application services to be ready
        run: |
          echo "Waiting for http://localhost:3000 (frontend) and http://localhost:2000/health (backend API)..."
          npx wait-on http://localhost:3000 http://localhost:2000/health --timeout 240000 # Increased timeout for robustness
          echo "All services are ready."

      - name: Show service logs if wait failed
        if: failure()
        run: |
          echo "=== Backend API logs ==="
          if [ -f "backend.log" ]; then
            cat backend.log
          else
            echo "No backend.log found"
          fi
          echo "=== Frontend logs ==="
          if [ -f "frontend.log" ]; then
            tail -n 50 frontend.log
          else
            echo "No frontend.log found"
          fi
          echo "=== Running processes ==="
          ps aux | grep -E "(node|npm)" | grep -v grep

      - name: Run Cypress tests
        run: npx cypress run
        env:
          # These envs are for Cypress itself if it needs them, or your frontend if it re-reads them
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASS: ${{ secrets.DB_PASS }}
          DB_NAME: ${{ secrets.DB_NAME }}
          REACT_APP_API_URL: http://localhost:2000

      - name: Upload Cypress artifacts
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: cypress-artifacts
          path: |
            cypress/videos
            cypress/screenshots
          retention-days: 7
  run-unit-tests:
    name: Run Unit Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: 22
      
      - name: Install root dependencies
        run: npm ci

      - name: Run unit tests with coverage
        # Your package.json script for running unit tests is 'test-coverage'
        run: npm run test-coverage

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        if: always() # Always run this step, even if tests fail
        with:
          name: unit-test-coverage-report
          path: tests/coverage
          retention-days: 7